/* tslint:disable */
/* eslint-disable */
/**
 * Astarte App Engine API
 * Astarte\'s AppEngine API is the main entry point for any operations which have an impact on devices and their data. Most Astarte applications would want to use this API to interact with devices, stream and receive data, and oversee their fleet.
 *
 * The version of the OpenAPI document: 0.10.2
 * Contact: info@ispirata.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface DeviceStatus
 */
export interface DeviceStatus {
    /**
     * The device ID.
     * @type {string}
     * @memberof DeviceStatus
     */
    id?: string;
    /**
     * A set of aliases and their tags. Each alias has an unique tag that identifies its purpose.
     * @type {object}
     * @memberof DeviceStatus
     */
    aliases?: object;
    /**
     * A dictionary of available (installed) interfaces on the device. For each interface version major and minor versions are provided. Interfaces that are listed here might not be available on the server (e.g. not installed).
     * @type {object}
     * @memberof DeviceStatus
     */
    introspection?: object;
    /**
     * True if the device is connected to the broker.
     * @type {boolean}
     * @memberof DeviceStatus
     */
    connected?: boolean;
    /**
     * Last connection to the broker timestamp.
     * @type {string}
     * @memberof DeviceStatus
     */
    last_connection?: string;
    /**
     * Last device disconnection timestamp.
     * @type {string}
     * @memberof DeviceStatus
     */
    last_disconnection?: string;
    /**
     * First registration attempt timestamp.
     * @type {string}
     * @memberof DeviceStatus
     */
    first_registration?: string;
    /**
     * First credentials request timestamp.
     * @type {string}
     * @memberof DeviceStatus
     */
    first_credentials_request?: string;
    /**
     * Last known device IP address.
     * @type {string}
     * @memberof DeviceStatus
     */
    last_seen_ip?: string;
    /**
     * Last known device IP address used while obtaining credentials.
     * @type {string}
     * @memberof DeviceStatus
     */
    last_credentials_request_ip?: string;
    /**
     * Total ammount of received payload bytes.
     * @type {number}
     * @memberof DeviceStatus
     */
    total_received_bytes?: number;
    /**
     * Total ammount of received messages.
     * @type {number}
     * @memberof DeviceStatus
     */
    total_received_msgs?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse200
     */
    data?: Array<string>;
    /**
     * 
     * @type {InlineResponse200Links}
     * @memberof InlineResponse200
     */
    links?: InlineResponse200Links;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {DeviceStatus}
     * @memberof InlineResponse2001
     */
    data?: DeviceStatus;
}
/**
 * 
 * @export
 * @interface InlineResponse200Links
 */
export interface InlineResponse200Links {
    /**
     * A relative link to this response.
     * @type {string}
     * @memberof InlineResponse200Links
     */
    self?: string;
    /**
     * A relative link to next devices list page.
     * @type {string}
     * @memberof InlineResponse200Links
     */
    next?: string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {NotFoundErrorErrors}
     * @memberof NotFoundError
     */
    errors?: NotFoundErrorErrors;
}
/**
 * 
 * @export
 * @interface NotFoundErrorErrors
 */
export interface NotFoundErrorErrors {
    /**
     * Short error description
     * @type {string}
     * @memberof NotFoundErrorErrors
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * 
     * @type {NotFoundErrorErrors}
     * @memberof UnauthorizedError
     */
    errors?: NotFoundErrorErrors;
}

/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Unset a value on a certain path, path is also deleted. Endpoint must support unset.
         * @summary Delete path and push an unset value message
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePathValue: async (realmName: string, deviceId: string, _interface: string, path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling deletePathValue.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deletePathValue.');
            }
            // verify required parameter '_interface' is not null or undefined
            if (_interface === null || _interface === undefined) {
                throw new RequiredError('_interface','Required parameter _interface was null or undefined when calling deletePathValue.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling deletePathValue.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces/{interface}/{path}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"interface"}}`, encodeURIComponent(String(_interface)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatus: async (realmName: string, deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getDeviceStatus.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getDeviceStatus.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatusByAlias: async (realmName: string, deviceAlias: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getDeviceStatusByAlias.');
            }
            // verify required parameter 'deviceAlias' is not null or undefined
            if (deviceAlias === null || deviceAlias === undefined) {
                throw new RequiredError('deviceAlias','Required parameter deviceAlias was null or undefined when calling getDeviceStatusByAlias.');
            }
            const localVarPath = `/{realm_name}/devices-by-alias/{device_alias}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_alias"}}`, encodeURIComponent(String(deviceAlias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * A paged list of all devices is returned. By default the device ID string is returned for each already registered device. The complete device status can be optionally retrieved rather than device ID string using details option.
         * @summary Get devices list
         * @param {string} realmName The name of the realm the device list will be returned from.
         * @param {number} [fromToken] Opaque devices list page pointer: it basically points to the beginning of a devices page. If not specified the devices list is displayed from the beginning. This format might change in future versions so it should be passed without any furhter assumption about type, format or its value.
         * @param {number} [limit] Maximum number of devices that will be returned for each page.
         * @param {boolean} [details] If true detailed device status for all devices is returned rather than the device id. See also DeviceStatus example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesList: async (realmName: string, fromToken?: number, limit?: number, details?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getDevicesList.');
            }
            const localVarPath = `/{realm_name}/devices`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fromToken !== undefined) {
                localVarQueryParameter['from_token'] = fromToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a values snapshot for a given interface on a certain device. This action performed on a data stream interface returns the most recent set of data for each endpoint. More specific APIs should be used for advances data stream actions.
         * @summary Get properties values
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfacePropertiesValues: async (realmName: string, deviceId: string, _interface: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getInterfacePropertiesValues.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getInterfacePropertiesValues.');
            }
            // verify required parameter '_interface' is not null or undefined
            if (_interface === null || _interface === undefined) {
                throw new RequiredError('_interface','Required parameter _interface was null or undefined when calling getInterfacePropertiesValues.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces/{interface}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"interface"}}`, encodeURIComponent(String(_interface)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a value on a given path. This action on a data production path returns the last entry if no query parameters are specified.
         * @summary Get property value
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {string} [since] Query all values since a certain timestamp (all entries where timestamp &gt;&#x3D; since). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already used. See also \&#39;since-after\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [sinceAfter] Query all values since after a certain timestamp (all entries where timestamp &gt; since_after). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already specified. See also \&#39;since\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [to] Query all values up to a certain timestamp. If since is not specified first entry date is assumed by default. This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. See also \&#39;since\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [limit] Limit number of retrieved data production entries to \&#39;limit\&#39;. This parameter must be always specified when \&#39;since\&#39;, \&#39;since-after\&#39; and \&#39;to\&#39; query parameters are used. If limit is specified without any \&#39;since\&#39; and \&#39;to\&#39; parameter, last \&#39;limit\&#39; values are retrieved. When \&#39;limit\&#39; entries are returned, it should be checked if any other entry is left by using since-after the last received timestamp.  An error is returned if limit exceeds maximum allowed value. See also \&#39;since\&#39; and \&#39;to\&#39; parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfacePropertyValue: async (realmName: string, deviceId: string, _interface: string, path: string, since?: string, sinceAfter?: string, to?: string, limit?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getInterfacePropertyValue.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getInterfacePropertyValue.');
            }
            // verify required parameter '_interface' is not null or undefined
            if (_interface === null || _interface === undefined) {
                throw new RequiredError('_interface','Required parameter _interface was null or undefined when calling getInterfacePropertyValue.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getInterfacePropertyValue.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces/{interface}/{path}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"interface"}}`, encodeURIComponent(String(_interface)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (sinceAfter !== undefined) {
                localVarQueryParameter['since_after'] = sinceAfter;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of interfaces supported by a certain device. Interfaces that are not reported by the device are not reported here. If a device stops to advertise a certain interface, it should be retrived from a different API, same applies for older versions of a certain interface.
         * @summary Get interfaces list
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfaces: async (realmName: string, deviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling getInterfaces.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getInterfaces.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream a value on a certain path. Endpoint must be a member of a datastream interface.
         * @summary Stream data
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamData: async (realmName: string, deviceId: string, _interface: string, path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling streamData.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling streamData.');
            }
            // verify required parameter '_interface' is not null or undefined
            if (_interface === null || _interface === undefined) {
                throw new RequiredError('_interface','Required parameter _interface was null or undefined when calling streamData.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling streamData.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces/{interface}/{path}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"interface"}}`, encodeURIComponent(String(_interface)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus: async (realmName: string, deviceId: string, body?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling updateDeviceStatus.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling updateDeviceStatus.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusByAlias: async (realmName: string, deviceAlias: string, body?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling updateDeviceStatusByAlias.');
            }
            // verify required parameter 'deviceAlias' is not null or undefined
            if (deviceAlias === null || deviceAlias === undefined) {
                throw new RequiredError('deviceAlias','Required parameter deviceAlias was null or undefined when calling updateDeviceStatusByAlias.');
            }
            const localVarPath = `/{realm_name}/devices-by-alias/{device_alias}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_alias"}}`, encodeURIComponent(String(deviceAlias)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/merge-patch+json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update and push a property value to the device on a certain endpoint path. interface should be an individual server owned property interface. It mustn\'t be used to stream data to a device or to update single properties that are members of an object aggregated interface.
         * @summary Update and push a value on a path
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePathValue: async (realmName: string, deviceId: string, _interface: string, path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmName' is not null or undefined
            if (realmName === null || realmName === undefined) {
                throw new RequiredError('realmName','Required parameter realmName was null or undefined when calling updatePathValue.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling updatePathValue.');
            }
            // verify required parameter '_interface' is not null or undefined
            if (_interface === null || _interface === undefined) {
                throw new RequiredError('_interface','Required parameter _interface was null or undefined when calling updatePathValue.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling updatePathValue.');
            }
            const localVarPath = `/{realm_name}/devices/{device_id}/interfaces/{interface}/{path}`
                .replace(`{${"realm_name"}}`, encodeURIComponent(String(realmName)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"interface"}}`, encodeURIComponent(String(_interface)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Unset a value on a certain path, path is also deleted. Endpoint must support unset.
         * @summary Delete path and push an unset value message
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).deletePathValue(realmName, deviceId, _interface, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceStatus(realmName: string, deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getDeviceStatus(realmName, deviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceStatusByAlias(realmName: string, deviceAlias: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getDeviceStatusByAlias(realmName, deviceAlias, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A paged list of all devices is returned. By default the device ID string is returned for each already registered device. The complete device status can be optionally retrieved rather than device ID string using details option.
         * @summary Get devices list
         * @param {string} realmName The name of the realm the device list will be returned from.
         * @param {number} [fromToken] Opaque devices list page pointer: it basically points to the beginning of a devices page. If not specified the devices list is displayed from the beginning. This format might change in future versions so it should be passed without any furhter assumption about type, format or its value.
         * @param {number} [limit] Maximum number of devices that will be returned for each page.
         * @param {boolean} [details] If true detailed device status for all devices is returned rather than the device id. See also DeviceStatus example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevicesList(realmName: string, fromToken?: number, limit?: number, details?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getDevicesList(realmName, fromToken, limit, details, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a values snapshot for a given interface on a certain device. This action performed on a data stream interface returns the most recent set of data for each endpoint. More specific APIs should be used for advances data stream actions.
         * @summary Get properties values
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterfacePropertiesValues(realmName: string, deviceId: string, _interface: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getInterfacePropertiesValues(realmName, deviceId, _interface, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a value on a given path. This action on a data production path returns the last entry if no query parameters are specified.
         * @summary Get property value
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {string} [since] Query all values since a certain timestamp (all entries where timestamp &gt;&#x3D; since). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already used. See also \&#39;since-after\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [sinceAfter] Query all values since after a certain timestamp (all entries where timestamp &gt; since_after). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already specified. See also \&#39;since\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [to] Query all values up to a certain timestamp. If since is not specified first entry date is assumed by default. This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. See also \&#39;since\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [limit] Limit number of retrieved data production entries to \&#39;limit\&#39;. This parameter must be always specified when \&#39;since\&#39;, \&#39;since-after\&#39; and \&#39;to\&#39; query parameters are used. If limit is specified without any \&#39;since\&#39; and \&#39;to\&#39; parameter, last \&#39;limit\&#39; values are retrieved. When \&#39;limit\&#39; entries are returned, it should be checked if any other entry is left by using since-after the last received timestamp.  An error is returned if limit exceeds maximum allowed value. See also \&#39;since\&#39; and \&#39;to\&#39; parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterfacePropertyValue(realmName: string, deviceId: string, _interface: string, path: string, since?: string, sinceAfter?: string, to?: string, limit?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getInterfacePropertyValue(realmName, deviceId, _interface, path, since, sinceAfter, to, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a list of interfaces supported by a certain device. Interfaces that are not reported by the device are not reported here. If a device stops to advertise a certain interface, it should be retrived from a different API, same applies for older versions of a certain interface.
         * @summary Get interfaces list
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterfaces(realmName: string, deviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).getInterfaces(realmName, deviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stream a value on a certain path. Endpoint must be a member of a datastream interface.
         * @summary Stream data
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamData(realmName: string, deviceId: string, _interface: string, path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).streamData(realmName, deviceId, _interface, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatus(realmName: string, deviceId: string, body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).updateDeviceStatus(realmName, deviceId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceStatusByAlias(realmName: string, deviceAlias: string, body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).updateDeviceStatusByAlias(realmName, deviceAlias, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update and push a property value to the device on a certain endpoint path. interface should be an individual server owned property interface. It mustn\'t be used to stream data to a device or to update single properties that are members of an object aggregated interface.
         * @summary Update and push a value on a path
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DeviceApiAxiosParamCreator(configuration).updatePathValue(realmName, deviceId, _interface, path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Unset a value on a certain path, path is also deleted. Endpoint must support unset.
         * @summary Delete path and push an unset value message
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).deletePathValue(realmName, deviceId, _interface, path, options).then((request) => request(axios, basePath));
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatus(realmName: string, deviceId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return DeviceApiFp(configuration).getDeviceStatus(realmName, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
         * @summary Get device general status
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatusByAlias(realmName: string, deviceAlias: string, options?: any): AxiosPromise<InlineResponse2001> {
            return DeviceApiFp(configuration).getDeviceStatusByAlias(realmName, deviceAlias, options).then((request) => request(axios, basePath));
        },
        /**
         * A paged list of all devices is returned. By default the device ID string is returned for each already registered device. The complete device status can be optionally retrieved rather than device ID string using details option.
         * @summary Get devices list
         * @param {string} realmName The name of the realm the device list will be returned from.
         * @param {number} [fromToken] Opaque devices list page pointer: it basically points to the beginning of a devices page. If not specified the devices list is displayed from the beginning. This format might change in future versions so it should be passed without any furhter assumption about type, format or its value.
         * @param {number} [limit] Maximum number of devices that will be returned for each page.
         * @param {boolean} [details] If true detailed device status for all devices is returned rather than the device id. See also DeviceStatus example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesList(realmName: string, fromToken?: number, limit?: number, details?: boolean, options?: any): AxiosPromise<InlineResponse200> {
            return DeviceApiFp(configuration).getDevicesList(realmName, fromToken, limit, details, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a values snapshot for a given interface on a certain device. This action performed on a data stream interface returns the most recent set of data for each endpoint. More specific APIs should be used for advances data stream actions.
         * @summary Get properties values
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfacePropertiesValues(realmName: string, deviceId: string, _interface: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).getInterfacePropertiesValues(realmName, deviceId, _interface, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a value on a given path. This action on a data production path returns the last entry if no query parameters are specified.
         * @summary Get property value
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {string} [since] Query all values since a certain timestamp (all entries where timestamp &gt;&#x3D; since). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already used. See also \&#39;since-after\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [sinceAfter] Query all values since after a certain timestamp (all entries where timestamp &gt; since_after). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already specified. See also \&#39;since\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [to] Query all values up to a certain timestamp. If since is not specified first entry date is assumed by default. This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. See also \&#39;since\&#39; and \&#39;limit\&#39; parameters.
         * @param {string} [limit] Limit number of retrieved data production entries to \&#39;limit\&#39;. This parameter must be always specified when \&#39;since\&#39;, \&#39;since-after\&#39; and \&#39;to\&#39; query parameters are used. If limit is specified without any \&#39;since\&#39; and \&#39;to\&#39; parameter, last \&#39;limit\&#39; values are retrieved. When \&#39;limit\&#39; entries are returned, it should be checked if any other entry is left by using since-after the last received timestamp.  An error is returned if limit exceeds maximum allowed value. See also \&#39;since\&#39; and \&#39;to\&#39; parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfacePropertyValue(realmName: string, deviceId: string, _interface: string, path: string, since?: string, sinceAfter?: string, to?: string, limit?: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).getInterfacePropertyValue(realmName, deviceId, _interface, path, since, sinceAfter, to, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of interfaces supported by a certain device. Interfaces that are not reported by the device are not reported here. If a device stops to advertise a certain interface, it should be retrived from a different API, same applies for older versions of a certain interface.
         * @summary Get interfaces list
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfaces(realmName: string, deviceId: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).getInterfaces(realmName, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stream a value on a certain path. Endpoint must be a member of a datastream interface.
         * @summary Stream data
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamData(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).streamData(realmName, deviceId, _interface, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatus(realmName: string, deviceId: string, body?: object, options?: any): AxiosPromise<InlineResponse2001> {
            return DeviceApiFp(configuration).updateDeviceStatus(realmName, deviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update any of the writeable device properties such as device aliases.
         * @summary Update a device writeable property
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceAlias One of the device aliases
         * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceStatusByAlias(realmName: string, deviceAlias: string, body?: object, options?: any): AxiosPromise<InlineResponse2001> {
            return DeviceApiFp(configuration).updateDeviceStatusByAlias(realmName, deviceAlias, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update and push a property value to the device on a certain endpoint path. interface should be an individual server owned property interface. It mustn\'t be used to stream data to a device or to update single properties that are members of an object aggregated interface.
         * @summary Update and push a value on a path
         * @param {string} realmName Name of the realm which the device belongs to.
         * @param {string} deviceId Device ID
         * @param {string} _interface Interface name
         * @param {string} path Endpoint Path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void> {
            return DeviceApiFp(configuration).updatePathValue(realmName, deviceId, _interface, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - interface
 * @export
 * @interface DeviceApi
 */
export interface DeviceApiInterface {
    /**
     * Unset a value on a certain path, path is also deleted. Endpoint must support unset.
     * @summary Delete path and push an unset value message
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    deletePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void>;

    /**
     * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
     * @summary Get device general status
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDeviceStatus(realmName: string, deviceId: string, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
     * @summary Get device general status
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceAlias One of the device aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDeviceStatusByAlias(realmName: string, deviceAlias: string, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * A paged list of all devices is returned. By default the device ID string is returned for each already registered device. The complete device status can be optionally retrieved rather than device ID string using details option.
     * @summary Get devices list
     * @param {string} realmName The name of the realm the device list will be returned from.
     * @param {number} [fromToken] Opaque devices list page pointer: it basically points to the beginning of a devices page. If not specified the devices list is displayed from the beginning. This format might change in future versions so it should be passed without any furhter assumption about type, format or its value.
     * @param {number} [limit] Maximum number of devices that will be returned for each page.
     * @param {boolean} [details] If true detailed device status for all devices is returned rather than the device id. See also DeviceStatus example.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getDevicesList(realmName: string, fromToken?: number, limit?: number, details?: boolean, options?: any): AxiosPromise<InlineResponse200>;

    /**
     * Get a values snapshot for a given interface on a certain device. This action performed on a data stream interface returns the most recent set of data for each endpoint. More specific APIs should be used for advances data stream actions.
     * @summary Get properties values
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getInterfacePropertiesValues(realmName: string, deviceId: string, _interface: string, options?: any): AxiosPromise<void>;

    /**
     * Retrieve a value on a given path. This action on a data production path returns the last entry if no query parameters are specified.
     * @summary Get property value
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {string} [since] Query all values since a certain timestamp (all entries where timestamp &gt;&#x3D; since). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already used. See also \&#39;since-after\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [sinceAfter] Query all values since after a certain timestamp (all entries where timestamp &gt; since_after). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already specified. See also \&#39;since\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [to] Query all values up to a certain timestamp. If since is not specified first entry date is assumed by default. This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. See also \&#39;since\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [limit] Limit number of retrieved data production entries to \&#39;limit\&#39;. This parameter must be always specified when \&#39;since\&#39;, \&#39;since-after\&#39; and \&#39;to\&#39; query parameters are used. If limit is specified without any \&#39;since\&#39; and \&#39;to\&#39; parameter, last \&#39;limit\&#39; values are retrieved. When \&#39;limit\&#39; entries are returned, it should be checked if any other entry is left by using since-after the last received timestamp.  An error is returned if limit exceeds maximum allowed value. See also \&#39;since\&#39; and \&#39;to\&#39; parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getInterfacePropertyValue(realmName: string, deviceId: string, _interface: string, path: string, since?: string, sinceAfter?: string, to?: string, limit?: string, options?: any): AxiosPromise<void>;

    /**
     * Get a list of interfaces supported by a certain device. Interfaces that are not reported by the device are not reported here. If a device stops to advertise a certain interface, it should be retrived from a different API, same applies for older versions of a certain interface.
     * @summary Get interfaces list
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    getInterfaces(realmName: string, deviceId: string, options?: any): AxiosPromise<void>;

    /**
     * Stream a value on a certain path. Endpoint must be a member of a datastream interface.
     * @summary Stream data
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    streamData(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void>;

    /**
     * Update any of the writeable device properties such as device aliases.
     * @summary Update a device writeable property
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    updateDeviceStatus(realmName: string, deviceId: string, body?: object, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Update any of the writeable device properties such as device aliases.
     * @summary Update a device writeable property
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceAlias One of the device aliases
     * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    updateDeviceStatusByAlias(realmName: string, deviceAlias: string, body?: object, options?: any): AxiosPromise<InlineResponse2001>;

    /**
     * Update and push a property value to the device on a certain endpoint path. interface should be an individual server owned property interface. It mustn\'t be used to stream data to a device or to update single properties that are members of an object aggregated interface.
     * @summary Update and push a value on a path
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApiInterface
     */
    updatePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any): AxiosPromise<void>;

}

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI implements DeviceApiInterface {
    /**
     * Unset a value on a certain path, path is also deleted. Endpoint must support unset.
     * @summary Delete path and push an unset value message
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deletePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any) {
        return DeviceApiFp(this.configuration).deletePathValue(realmName, deviceId, _interface, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
     * @summary Get device general status
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDeviceStatus(realmName: string, deviceId: string, options?: any) {
        return DeviceApiFp(this.configuration).getDeviceStatus(realmName, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device overview status is returned. Overview includes an array of reported interfaces (introspection), offline/online status, etc...
     * @summary Get device general status
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceAlias One of the device aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDeviceStatusByAlias(realmName: string, deviceAlias: string, options?: any) {
        return DeviceApiFp(this.configuration).getDeviceStatusByAlias(realmName, deviceAlias, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A paged list of all devices is returned. By default the device ID string is returned for each already registered device. The complete device status can be optionally retrieved rather than device ID string using details option.
     * @summary Get devices list
     * @param {string} realmName The name of the realm the device list will be returned from.
     * @param {number} [fromToken] Opaque devices list page pointer: it basically points to the beginning of a devices page. If not specified the devices list is displayed from the beginning. This format might change in future versions so it should be passed without any furhter assumption about type, format or its value.
     * @param {number} [limit] Maximum number of devices that will be returned for each page.
     * @param {boolean} [details] If true detailed device status for all devices is returned rather than the device id. See also DeviceStatus example.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getDevicesList(realmName: string, fromToken?: number, limit?: number, details?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).getDevicesList(realmName, fromToken, limit, details, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a values snapshot for a given interface on a certain device. This action performed on a data stream interface returns the most recent set of data for each endpoint. More specific APIs should be used for advances data stream actions.
     * @summary Get properties values
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getInterfacePropertiesValues(realmName: string, deviceId: string, _interface: string, options?: any) {
        return DeviceApiFp(this.configuration).getInterfacePropertiesValues(realmName, deviceId, _interface, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a value on a given path. This action on a data production path returns the last entry if no query parameters are specified.
     * @summary Get property value
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {string} [since] Query all values since a certain timestamp (all entries where timestamp &gt;&#x3D; since). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already used. See also \&#39;since-after\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [sinceAfter] Query all values since after a certain timestamp (all entries where timestamp &gt; since_after). This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. It can\&#39;t be used if since is already specified. See also \&#39;since\&#39;, to\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [to] Query all values up to a certain timestamp. If since is not specified first entry date is assumed by default. This query parameter applies only on data streams. It must be a ISO 8601 valid timestamp. See also \&#39;since\&#39; and \&#39;limit\&#39; parameters.
     * @param {string} [limit] Limit number of retrieved data production entries to \&#39;limit\&#39;. This parameter must be always specified when \&#39;since\&#39;, \&#39;since-after\&#39; and \&#39;to\&#39; query parameters are used. If limit is specified without any \&#39;since\&#39; and \&#39;to\&#39; parameter, last \&#39;limit\&#39; values are retrieved. When \&#39;limit\&#39; entries are returned, it should be checked if any other entry is left by using since-after the last received timestamp.  An error is returned if limit exceeds maximum allowed value. See also \&#39;since\&#39; and \&#39;to\&#39; parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getInterfacePropertyValue(realmName: string, deviceId: string, _interface: string, path: string, since?: string, sinceAfter?: string, to?: string, limit?: string, options?: any) {
        return DeviceApiFp(this.configuration).getInterfacePropertyValue(realmName, deviceId, _interface, path, since, sinceAfter, to, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of interfaces supported by a certain device. Interfaces that are not reported by the device are not reported here. If a device stops to advertise a certain interface, it should be retrived from a different API, same applies for older versions of a certain interface.
     * @summary Get interfaces list
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public getInterfaces(realmName: string, deviceId: string, options?: any) {
        return DeviceApiFp(this.configuration).getInterfaces(realmName, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream a value on a certain path. Endpoint must be a member of a datastream interface.
     * @summary Stream data
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public streamData(realmName: string, deviceId: string, _interface: string, path: string, options?: any) {
        return DeviceApiFp(this.configuration).streamData(realmName, deviceId, _interface, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update any of the writeable device properties such as device aliases.
     * @summary Update a device writeable property
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public updateDeviceStatus(realmName: string, deviceId: string, body?: object, options?: any) {
        return DeviceApiFp(this.configuration).updateDeviceStatus(realmName, deviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update any of the writeable device properties such as device aliases.
     * @summary Update a device writeable property
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceAlias One of the device aliases
     * @param {object} [body] A JSON Merge Patch containing the property changes which should be applied to the device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public updateDeviceStatusByAlias(realmName: string, deviceAlias: string, body?: object, options?: any) {
        return DeviceApiFp(this.configuration).updateDeviceStatusByAlias(realmName, deviceAlias, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update and push a property value to the device on a certain endpoint path. interface should be an individual server owned property interface. It mustn\'t be used to stream data to a device or to update single properties that are members of an object aggregated interface.
     * @summary Update and push a value on a path
     * @param {string} realmName Name of the realm which the device belongs to.
     * @param {string} deviceId Device ID
     * @param {string} _interface Interface name
     * @param {string} path Endpoint Path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public updatePathValue(realmName: string, deviceId: string, _interface: string, path: string, options?: any) {
        return DeviceApiFp(this.configuration).updatePathValue(realmName, deviceId, _interface, path, options).then((request) => request(this.axios, this.basePath));
    }
}


